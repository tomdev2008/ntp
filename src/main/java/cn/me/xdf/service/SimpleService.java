package cn.me.xdf.service;import cn.me.xdf.common.hibernate4.BaseDao;import cn.me.xdf.common.hibernate4.Finder;import cn.me.xdf.common.hibernate4.OrderBy;import cn.me.xdf.common.hibernate4.Updater;import cn.me.xdf.common.page.Pagination;import cn.me.xdf.model.base.IdEntity;import org.hibernate.criterion.Criterion;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.transaction.annotation.Transactional;import java.io.Serializable;import java.util.List;import java.util.Map;/** * 所有service层建议继承此类. * <p> * 此类里有一些简单的增删改查，也可以调用getBaseDao()对方法进行扩展。 * </p> * * @author xiaobin * */@Transactional(readOnly = true)public class SimpleService {    /**     * 分页查询     *     * @param finder     *            查询构造器     * @param pageNo     *            页码     * @return     */    @Transactional(readOnly = true)    public Pagination getPage(Finder finder, Integer pageNo) {        if (pageNo == null)            pageNo = 1;        return getBaseDao().find(finder, pageNo);    }    /**     * 分页查询     *     * @param finder     *            查询构造器     * @param pageNo     *            页码     * @param pageSize     *            每页几条数据     * @return     */    @Transactional(readOnly = true)    public Pagination getPage(Finder finder, Integer pageNo, Integer pageSize) {        return getBaseDao().find(finder, pageNo, pageSize);    }    /**     * 查询在xxx.dynamic.xml中配置的查询语句     * <p>     * 可查询sql或者hql占位符的语句,也可以直接写sql或者hql     * </p>     *     * @param queryName     * @param parameters     * @param clazz     * @return     */    @Transactional(readOnly = true)    public <X> List<X> findByNamedQuery(final String queryName,                                        final Map<String, Object> parameters, Class<X> clazz) {        return getBaseDao().findByNamedQuery(queryName, parameters, clazz);    }    /**     * 查询在xxx.dynamic.xml中配置的查询语句     *     * <p>     * 可查询sql或者hql占位符的语句,也可以直接写sql或者hql     * </p>     *     * @param queryName     * @param parameters     * @param clazz     * @param pageNo     * @return     */    @Transactional(readOnly = true)    public Pagination findByNamedPage(final String queryName,                                      final Map<String, Object> parameters, Class<?> clazz, int pageNo) {        return getBaseDao().findByNamedPage(queryName, parameters, clazz,                pageNo);    }    /**     * 更新xxx.dynamic.xml中配置的更新语句     * <p>     * 可更新sql或者hql占位符的语句，也可以直接写sql或者hql     * </p>     *     * @param queryName     * @param parameters     * @return     */    @Transactional(readOnly = false)    public int updateByNamedQuery(final String queryName,                                  final Map<String, ?> parameters) {        return getBaseDao().updateByNamedQuery(queryName, parameters);    }    /**     * 桉属性查找数据     *     * @param property     * @param value     * @return     */    @Transactional(readOnly = true)    public <T> List<T> findByProperty(Class<T> clazz,String property, Object value) {        return (List<T>) getBaseDao().findByProperty(clazz,                property, value);    }    /**     * 根据属性值获取唯一的数据     *     * @param property     * @param value     * @return     */    @Transactional(readOnly = true)    public <T> T findUniqueByProperty(Class<T> clazz,String property, Object value) {        return (T) getBaseDao().findUniqueByProperty(clazz,                property, value);    }    /**     * 根据属性值获取唯一的数据     *     * @param clazz     * @param criterion     * @return     */    @Transactional(readOnly = true)    public <T> T findUniqueByProperty(Class<T> clazz, Criterion... criterion) {        return getBaseDao().findUniqueByProperty(clazz, criterion);    }    /**     * 根据Finder查询数据     *     * @param finder     * @return     */    @Transactional(readOnly = true)    @SuppressWarnings("rawtypes")    public List find(Finder finder) {        return getBaseDao().find(finder);    }        /**     * 根据Finder查询唯一数据     * @param finder     * @return     */    public <T> T findUnique(Finder finder) {        return getBaseDao().findUnique(finder);    }    public boolean hasValue(Finder finder) {        return getBaseDao().hasValue(finder);    }    /**     * 用法: .findByCriteria(T.class, Value.eq("fdId", id));     * <p>     * Value提供了非常多的查询表达式     * </p>     *     * @param clazz     * @param criterion     * @return     */    @Transactional(readOnly = true)    @SuppressWarnings("unchecked")    public <T> List<T> findByCriteria(Class<T> clazz, Criterion... criterion) {        return getBaseDao().findByCriteria(clazz, criterion);    }    @Transactional(readOnly = true)    public <T> List<T> findByCriteria(Class<T> clazz, OrderBy order,                                      Criterion... criterion) {        return getBaseDao().findByCriteria(clazz, OrderBy.asOrders(order),                criterion);    }        	/**	 * 用法: .findByCriteria(T.class, 20,Value.eq("fdId", id));	 * 	 * @param clazz	 * @param maxCount	 *            前几条数据	 * @param criterion	 * @param <T>	 * @return	 */	public <T> List<T> findByCriteria(Class<T> clazz, int maxCount,			Criterion... criterion) {		return getBaseDao().findByCriteria(clazz, maxCount, criterion);	}    /**     * 用法: .findByCriteria(T.class, Value.eq("fdId", id));     * <p>     * Value提供了非常多的查询表达式     * </p>     *     * @param clazz     * @param criterion     * @return     */    @Transactional(readOnly = true)    public <T> List<T> findByCriteria(Class<T> clazz, OrderBy[] order,                                      Criterion... criterion) {        return getBaseDao().findByCriteria(clazz, order, criterion);    }            public <X> List<X> findBySQL(final String sql, Class<?> clazz,			final Map<String, ?> values){    	return getBaseDao().findBySQL(sql, clazz, values);    }    /**     * get Object     *     * @param id     * @return     */    @Transactional(readOnly = true)    public <T> T get(Class<T> clazz,Serializable id) {        return (T) getBaseDao().get(clazz, id);    }    /**     * load Object     *     * @param id     * @return     */    @Transactional(readOnly = true)    public <T> T load(Class<T> clazz,Serializable id) {        return (T) getBaseDao().load(clazz, id);    }    @Transactional(readOnly = false)    public <T extends IdEntity> T save(T entity) {    	        return getBaseDao().merge(entity);    }        @Transactional(readOnly = false)    public Object saveObj(Object entity) {        return getBaseDao().merge(entity);    }            @Transactional(readOnly = false)    public <T extends IdEntity> T update(T entity) {        return getBaseDao().update(entity);    }    @Transactional(readOnly = false)    public <T extends IdEntity> T saveOnly(T entity) {        return getBaseDao().save(entity);    }    @Transactional(readOnly = false)    public <T> void delete(Class<T> clazz,Serializable id) {        getBaseDao().deleteById(clazz, id);    }    @Transactional(readOnly = false)    public <T> void deleteEntity(T entity) {        getBaseDao().delete(entity);    }    @Transactional(readOnly = false)    public <T> void delete(Class<T> clazz,Serializable[] ids) {        if (ids == null)            return;        for (Serializable id : ids) {            getBaseDao().deleteById(clazz, id);        }    }        public void executeSql(String sql,Object...values){    	getBaseDao().executeSql(sql, values);    }       /**     * 自定义更新策略     * <p>     * 提供三种更新模式：MAX, MIN, MIDDLE     * </p>     * <ul>     * <li>MIDDLE：默认模式。除了null外，都更新。exclude和include例外。</li>     * <li>MAX：最大化更新模式。所有字段都更新（包括null）。exclude例外。</li>     * <li>MIN：最小化更新模式。所有字段都不更新。include例外。</li>     * </ul>     *     * @param updater     * @return     */    @Transactional(readOnly = false)    public <T> T updateByUpdater(Updater<T> updater) {        return getBaseDao().updateByUpdater(updater);    }    /**     * <p>     * 初始化对象. 使用load()方法得到的仅是对象Proxy, 在传到View层前需要进行初始化. 如果传入entity,     * 则只初始化entity的直接属性,但不会初始化延迟加载的关联集合和属性. 如需初始化关联属性,需执行:     * Hibernate.initialize(user.getRoles())，初始化User的直接属性和关联集合.     * Hibernate.initialize     * (user.getDescription())，初始化User的直接属性和延迟加载的Description属性.     * </p>     *     * @param proxy     */    public void initProxyObject(Object proxy) {        getBaseDao().initProxyObject(proxy);    }    private BaseDao baseDao;    protected BaseDao getBaseDao() {        return baseDao;    }    @Autowired    public void setBaseDao(BaseDao baseDao) {        this.baseDao = baseDao;    }}